# Generated by codegen.py
# Do not edit this file directly.
from __future__ import annotations

from enum import IntEnum
from collections.abc import ByteString, Callable, Iterator, Sequence
from typing import (
    Annotated,
    Any,
    Final,
    Generic,
    Literal,
    NamedTuple,
    Protocol,
    Self,
    TypeVar,
    overload,
    override,
)
from typing_extensions import deprecated

class _SupportsFileno(Protocol):
    def fileno(self) -> int: ...

class Point(NamedTuple):
    row: int
    column: int

class LogType(IntEnum):
    PARSE: int
    LEX: int

class Language:
    @overload
    @deprecated("int argument support is deprecated")
    def __init__(self, ptr: Annotated[int, "TSLanguage *"], /) -> None: ...
    @overload
    def __init__(self, ptr: Annotated[object, "TSLanguage *"], /) -> None: ...
    @property
    def name(self) -> str | None: ...
    @property
    def abi_version(self) -> int: ...
    @property
    def semantic_version(self) -> tuple[int, int, int] | None: ...
    @deprecated("Use abi_version instead")
    @property
    def version(self) -> int: ...
    @property
    def node_kind_count(self) -> int: ...
    @property
    def parse_state_count(self) -> int: ...
    @property
    def field_count(self) -> int: ...
    @property
    def supertypes(self) -> tuple[int, ...]: ...
    def subtypes(self, supertype: int, /) -> tuple[int, ...]: ...
    def node_kind_for_id(self, id: int, /) -> str | None: ...
    def id_for_node_kind(self, kind: str, named: bool, /) -> int | None: ...
    def node_kind_is_named(self, id: int, /) -> bool: ...
    def node_kind_is_visible(self, id: int, /) -> bool: ...
    def node_kind_is_supertype(self, id: int, /) -> bool: ...
    def field_name_for_id(self, field_id: int, /) -> str | None: ...
    def field_id_for_name(self, name: str, /) -> int | None: ...
    def next_state(self, state: int, id: int, /) -> int: ...
    def lookahead_iterator(self, state: int, /) -> LookaheadIterator | None: ...
    @deprecated("Use the Query() constructor instead")
    def query(self, source: str, /) -> Query: ...
    def copy(self) -> Language: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: Any, /) -> bool: ...
    def __ne__(self, other: Any, /) -> bool: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> Language: ...

T = TypeVar("T", bound=TypeString, default=TypeString, contravariant=True)

class Node(Generic[T]):
    @property
    def id(self) -> int: ...
    @property
    def kind_id(self) -> int: ...
    @property
    def grammar_id(self) -> int: ...
    @property
    def grammar_name(self) -> str: ...
    @property
    def type(self) -> T: ...
    @property
    def is_named(self) -> bool: ...
    @property
    def is_extra(self) -> bool: ...
    @property
    def has_changes(self) -> bool: ...
    @property
    def has_error(self) -> bool: ...
    @property
    def is_error(self) -> bool: ...
    @property
    def parse_state(self) -> int: ...
    @property
    def next_parse_state(self) -> int: ...
    @property
    def is_missing(self) -> bool: ...
    @property
    def start_byte(self) -> int: ...
    @property
    def end_byte(self) -> int: ...
    @property
    def byte_range(self) -> tuple[int, int]: ...
    @property
    def range(self) -> Range: ...
    @property
    def start_point(self) -> Point: ...
    @property
    def end_point(self) -> Point: ...
    @property
    def children(self) -> list[HclNode]: ...
    @property
    def child_count(self) -> int: ...
    @property
    def named_children(self) -> list[HclNode]: ...
    @property
    def named_child_count(self) -> int: ...
    @property
    def parent(self) -> HclNode | None: ...
    @property
    def next_sibling(self) -> HclNode | None: ...
    @property
    def prev_sibling(self) -> HclNode | None: ...
    @property
    def next_named_sibling(self) -> HclNode | None: ...
    @property
    def prev_named_sibling(self) -> HclNode | None: ...
    @property
    def descendant_count(self) -> int: ...
    @property
    def text(self) -> bytes | None: ...
    def walk(self) -> TreeCursor: ...
    def edit(
        self,
        start_byte: int,
        old_end_byte: int,
        new_end_byte: int,
        start_point: Point | tuple[int, int],
        old_end_point: Point | tuple[int, int],
        new_end_point: Point | tuple[int, int],
    ) -> None: ...
    def child(self, index: int, /) -> HclNode | None: ...
    def named_child(self, index: int, /) -> HclNode | None: ...
    def first_child_for_byte(self, byte: int, /) -> HclNode | None: ...
    def first_named_child_for_byte(self, byte: int, /) -> HclNode | None: ...
    def child_by_field_id(self, id: int, /) -> HclNode | None: ...
    def child_by_field_name(self, name: TypeString, /) -> HclNode | None: ...
    def child_with_descendant(self, descendant: HclNode, /) -> HclNode | None: ...
    def children_by_field_id(self, id: int, /) -> list[HclNode]: ...
    def children_by_field_name(self, name: TypeString, /) -> list[HclNode]: ...
    def field_name_for_child(self, child_index: int, /) -> str | None: ...
    def field_name_for_named_child(self, child_index: int, /) -> str | None: ...
    def descendant_for_byte_range(
        self,
        start_byte: int,
        end_byte: int,
        /,
    ) -> HclNode | None: ...
    def named_descendant_for_byte_range(
        self,
        start_byte: int,
        end_byte: int,
        /,
    ) -> HclNode | None: ...
    def descendant_for_point_range(
        self,
        start_point: Point | tuple[int, int],
        end_point: Point | tuple[int, int],
        /,
    ) -> HclNode | None: ...
    def named_descendant_for_point_range(
        self,
        start_point: Point | tuple[int, int],
        end_point: Point | tuple[int, int],
        /,
    ) -> HclNode | None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: Any, /) -> bool: ...
    def __ne__(self, other: Any, /) -> bool: ...
    def __hash__(self) -> int: ...

class Tree:
    @property
    def root_node(self) -> HclNode: ...
    @property
    def included_ranges(self) -> list[Range]: ...
    @property
    def language(self) -> Language: ...
    def root_node_with_offset(
        self,
        offset_bytes: int,
        offset_extent: Point | tuple[int, int],
        /,
    ) -> HclNode | None: ...
    def copy(self) -> Tree: ...
    def edit(
        self,
        start_byte: int,
        old_end_byte: int,
        new_end_byte: int,
        start_point: Point | tuple[int, int],
        old_end_point: Point | tuple[int, int],
        new_end_point: Point | tuple[int, int],
    ) -> None: ...
    def walk(self) -> TreeCursor: ...
    def changed_ranges(self, new_tree: Tree, /) -> list[Range]: ...
    def print_dot_graph(self, file: _SupportsFileno, /) -> None: ...
    def __copy__(self) -> Tree: ...

class TreeCursor:
    @property
    def node(self) -> HclNode | None: ...
    @property
    def field_id(self) -> int | None: ...
    @property
    def field_name(self) -> str | None: ...
    @property
    def depth(self) -> int: ...
    @property
    def descendant_index(self) -> int: ...
    def copy(self) -> TreeCursor: ...
    def reset(self, node: HclNode, /) -> None: ...
    def reset_to(self, cursor: TreeCursor, /) -> None: ...
    def goto_first_child(self) -> bool: ...
    def goto_last_child(self) -> bool: ...
    def goto_parent(self) -> bool: ...
    def goto_next_sibling(self) -> bool: ...
    def goto_previous_sibling(self) -> bool: ...
    def goto_descendant(self, index: int, /) -> None: ...
    def goto_first_child_for_byte(self, byte: int, /) -> int | None: ...
    def goto_first_child_for_point(
        self, point: Point | tuple[int, int], /
    ) -> int | None: ...
    def __copy__(self) -> TreeCursor: ...

class Parser:
    @overload
    def __init__(
        self,
        language: Language | None = None,
        *,
        included_ranges: Sequence[Range] | None = None,
        logger: Callable[[LogType, str], None] | None = None,
    ) -> None: ...
    @deprecated("timeout_micros is deprecated")
    @overload
    def __init__(
        self,
        language: Language | None = None,
        *,
        included_ranges: Sequence[Range] | None = None,
        timeout_micros: int | None = None,
        logger: Callable[[LogType, str], None] | None = None,
    ) -> None: ...
    @property
    def language(self) -> Language | None: ...
    @language.setter
    def language(self, language: Language) -> None: ...
    @language.deleter
    def language(self) -> None: ...
    @property
    def included_ranges(self) -> list[Range]: ...
    @included_ranges.setter
    def included_ranges(self, ranges: Sequence[Range]) -> None: ...
    @included_ranges.deleter
    def included_ranges(self) -> None: ...
    @deprecated("Use the progress_callback in parse()")
    @property
    def timeout_micros(self) -> int: ...
    @deprecated("Use the progress_callback in parse()")
    @timeout_micros.setter
    def timeout_micros(self, timeout: int) -> None: ...
    @deprecated("Use the progress_callback in parse()")
    @timeout_micros.deleter
    def timeout_micros(self) -> None: ...
    @property
    def logger(self) -> Callable[[LogType, str], None] | None: ...
    @logger.setter
    def logger(self, logger: Callable[[LogType, str], None]) -> None: ...
    @logger.deleter
    def logger(self) -> None: ...
    @overload
    def parse(
        self,
        source: ByteString,
        /,
        old_tree: Tree | None = None,
        encoding: Literal["utf8", "utf16", "utf16le", "utf16be"] = "utf8",
    ) -> Tree: ...
    @overload
    def parse(
        self,
        read_callback: Callable[[int, Point], bytes | None],
        /,
        old_tree: Tree | None = None,
        encoding: Literal["utf8", "utf16", "utf16le", "utf16be"] = "utf8",
        progress_callback: Callable[[int, bool], bool] | None = None,
    ) -> Tree: ...
    def reset(self) -> None: ...
    def print_dot_graphs(self, file: _SupportsFileno | None, /) -> None: ...

class QueryError(ValueError): ...

class QueryPredicate(Protocol):
    def __call__(
        self,
        predicate: str,
        args: list[tuple[str, Literal["capture", "string"]]],
        pattern_index: int,
        captures: dict[str, list[HclNode]],
    ) -> bool: ...

class Query:
    def __new__(cls, language: Language, source: str, /) -> Self: ...
    def pattern_count(self) -> int: ...
    def capture_count(self) -> int: ...
    def string_count(self) -> int: ...
    def start_byte_for_pattern(self, index: int, /) -> int: ...
    def end_byte_for_pattern(self, index: int, /) -> int: ...
    def is_pattern_rooted(self, index: int, /) -> bool: ...
    def is_pattern_non_local(self, index: int, /) -> bool: ...
    def is_pattern_guaranteed_at_step(self, index: int, /) -> bool: ...
    def capture_name(self, index: int, /) -> str: ...
    def capture_quantifier(
        self, pattern_index: int, capture_index: int, /
    ) -> Literal["", "?", "*", "+"]: ...
    def string_value(self, index: int, /) -> str: ...
    def disable_capture(self, name: str, /) -> None: ...
    def disable_pattern(self, index: int, /) -> None: ...
    def pattern_settings(self, index: int, /) -> dict[str, str | None]: ...
    def pattern_assertions(
        self, index: int, /
    ) -> dict[str, tuple[str | None, bool]]: ...

class QueryCursor:
    @overload
    def __init__(self, query: Query, *, match_limit: int = 0xFFFFFFFF) -> None: ...
    @deprecated("timeout_micros is deprecated")
    @overload
    def __init__(
        self, query: Query, *, match_limit: int = 0xFFFFFFFF, timeout_micros: int = 0
    ) -> None: ...
    @property
    def match_limit(self) -> int: ...
    @match_limit.setter
    def match_limit(self, limit: int) -> None: ...
    @match_limit.deleter
    def match_limit(self) -> None: ...
    @deprecated("Use the progress_callback in matches() or captures()")
    @property
    def timeout_micros(self) -> int: ...
    @deprecated("Use the progress_callback in matches() or captures()")
    @timeout_micros.setter
    def timeout_micros(self, timeout: int) -> None: ...
    @property
    def did_exceed_match_limit(self) -> bool: ...
    def set_max_start_depth(self, depth: int, /) -> None: ...
    def set_byte_range(self, start: int, end: int, /) -> None: ...
    def set_point_range(
        self,
        start: Point | tuple[int, int],
        end: Point | tuple[int, int],
        /,
    ) -> None: ...
    def captures(
        self,
        node: HclNode,
        predicate: QueryPredicate | None = None,
        progress_callback: Callable[[int], bool] | None = None,
        /,
    ) -> dict[str, list[HclNode]]: ...
    def matches(
        self,
        node: HclNode,
        predicate: QueryPredicate | None = None,
        progress_callback: Callable[[int], bool] | None = None,
        /,
    ) -> list[tuple[int, dict[str, list[HclNode]]]]: ...

class LookaheadIterator(Iterator[tuple[int, str]]):
    @property
    def language(self) -> Language: ...
    @property
    def current_symbol(self) -> int: ...
    @property
    def current_symbol_name(self) -> str: ...
    def reset(self, state: int, /, language: Language | None = None) -> bool: ...
    def names(self) -> list[str]: ...
    def symbols(self) -> list[int]: ...
    def __next__(self) -> tuple[int, str]: ...

class Range:
    def __init__(
        self,
        start_point: Point | tuple[int, int],
        end_point: Point | tuple[int, int],
        start_byte: int,
        end_byte: int,
    ) -> None: ...
    @property
    def start_point(self) -> Point: ...
    @property
    def end_point(self) -> Point: ...
    @property
    def start_byte(self) -> int: ...
    @property
    def end_byte(self) -> int: ...
    def __eq__(self, other: Any, /) -> bool: ...
    def __ne__(self, other: Any, /) -> bool: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...

LANGUAGE_VERSION: Final[int]

MIN_COMPATIBLE_LANGUAGE_VERSION: Final[int]

class NamedNode[T: TypeString](Node[T]):
    @property
    @override
    def is_named(self) -> Literal[True]: ...

class UnnamedNode[T: TypeString](Node[T]):
    @property
    @override
    def is_named(self) -> Literal[False]: ...

SyntaxType = Literal[
    "quoted_template",
    "string_lit",
    "template_interpolation",
    "template_interpolation_end",
    "object_start",
    "function_call",
    "heredoc_start",
    "heredoc_identifier",
    "block_start",
    "body",
    "function_arguments",
    "heredoc_template",
    "unary_operation",
    "block",
    "template_directive",
    "get_attr",
    "object",
    "tuple_start",
    "numeric_lit",
    "attr_splat",
    "bool_lit",
    "for_initializer_pair",
    "template_if_end",
    "new_index",
    "ellipsis",
    "for_tuple_expr",
    "template_directive_end",
    "template_literal",
    "for_expr",
    "parenthesized_expression",
    "template_else_intro",
    "for_intro",
    "template_interpolation_start",
    "template_for",
    "quoted_template_start",
    "config_file",
    "full_splat",
    "literal_value",
    "block_end",
    "null_lit",
    "strip_marker",
    "conditional",
    "for_object_expr",
    "legacy_index",
    "binary_operation",
    "quoted_template_end",
    "template_directive_start",
    "splat",
    "template_if_intro",
    "expr_term",
    "tuple",
    "collection_value",
    "tuple_end",
    "object_end",
    "identifier",
    "for_cond",
    "expression",
    "template_if",
    "template",
    "comment",
    "for_initializer_single",
    "template_for_end",
    "index",
    "object_elem",
    "template_for_start",
    "attribute",
]
UnnamedType = Literal[
    "+",
    "?",
    "if",
    "==",
    "{",
    "[*]",
    "&&",
    "-",
    "=>",
    ">",
    "/",
    ">=",
    ":",
    "(",
    "endif",
    ",",
    ")",
    "in",
    "false",
    "<",
    "<<-",
    "endfor",
    "true",
    "<=",
    "[",
    "=",
    ".*",
    "for",
    "<<",
    ".",
    "!",
    "*",
    "]",
    "||",
    "%",
    "}",
    "else",
    "!=",
]

type TypeString = SyntaxType | UnnamedType

class AttrSplat(NamedNode[Literal["attr_splat"]]):
    ...
    @override
    def child_by_field_name(self, name: Literal["expression"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class Attribute(NamedNode[Literal["attribute"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["left"], /) -> Identifier: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["right"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class BinaryOperation(NamedNode[Literal["binary_operation"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["left"], /) -> ExprTerm: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["operator"], /
    ) -> (
        UnnamedNode[Literal["!="]]
        | UnnamedNode[Literal["%"]]
        | UnnamedNode[Literal["&&"]]
        | UnnamedNode[Literal["*"]]
        | UnnamedNode[Literal["+"]]
        | UnnamedNode[Literal["-"]]
        | UnnamedNode[Literal["/"]]
        | UnnamedNode[Literal["<"]]
        | UnnamedNode[Literal["<="]]
        | UnnamedNode[Literal["=="]]
        | UnnamedNode[Literal[">"]]
        | UnnamedNode[Literal[">="]]
        | UnnamedNode[Literal["||"]]
    ): ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["right"], /) -> ExprTerm: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class Block(NamedNode[Literal["block"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["body"], /) -> Body | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @override
    def children_by_field_name(
        self, name: Literal["labels"], /
    ) -> list[Identifier | StringLit]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["type"], /) -> Identifier: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[BlockEnd | BlockStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[BlockEnd | BlockStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class BlockEnd(NamedNode[Literal["block_end"]]): ...
class BlockStart(NamedNode[Literal["block_start"]]): ...

class Body(NamedNode[Literal["body"]]):
    ...
    @override
    @overload
    def children_by_field_name(
        self, name: Literal["attributes"], /
    ) -> list[Attribute]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def children_by_field_name(self, name: Literal["blocks"], /) -> list[Block]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class BoolLit(NamedNode[Literal["bool_lit"]]): ...

class Conditional(NamedNode[Literal["conditional"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["alternative"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["condition"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["consequence"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class ConfigFile(NamedNode[Literal["config_file"]]):
    ...

    @property
    @override
    def named_children(self) -> list[Body | Object]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[Body | Object]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class ForInitializerPair(NamedNode[Literal["for_initializer_pair"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["left"], /) -> Identifier: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["right"], /) -> Identifier: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class ForIntro(NamedNode[Literal["for_intro"]]):
    ...
    @override
    @overload
    def child_by_field_name(
        self, name: Literal["left"], /
    ) -> ForInitializerPair | ForInitializerSingle: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["right"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class ForObjectExpr(NamedNode[Literal["for_object_expr"]]):
    ...
    @override
    @overload
    def child_by_field_name(
        self, name: Literal["condition"], /
    ) -> Expression | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["expansion"], /) -> Ellipsis | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["intro"], /) -> ForIntro: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["key"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["value"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[ObjectEnd | ObjectStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[ObjectEnd | ObjectStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class ForTupleExpr(NamedNode[Literal["for_tuple_expr"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["body"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["condition"], /
    ) -> Expression | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["intro"], /) -> ForIntro: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[TupleEnd | TupleStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[TupleEnd | TupleStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class FullSplat(NamedNode[Literal["full_splat"]]):
    ...
    @override
    def child_by_field_name(self, name: Literal["expression"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class FunctionCall(NamedNode[Literal["function_call"]]):
    ...
    @override
    def children_by_field_name(
        self, name: Literal["arguments"], /
    ) -> list[Expression]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @override
    def child_by_field_name(self, name: Literal["function"], /) -> Identifier: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[Ellipsis]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[Ellipsis]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class GetAttr(NamedNode[Literal["get_attr"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["attribute"], /) -> Identifier: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["object"], /) -> ExprTerm: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class HeredocStart(NamedNode[Literal["heredoc_start"]]): ...

class HeredocTemplate(NamedNode[Literal["heredoc_template"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["body"], /) -> Template | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["heredoc_marker"], /
    ) -> HeredocStart: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[HeredocIdentifier]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[HeredocIdentifier]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class Index(NamedNode[Literal["index"]]):
    ...
    @override
    @overload
    def child_by_field_name(
        self, name: Literal["index"], /
    ) -> LegacyIndex | NewIndex: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["object"], /) -> ExprTerm: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class LegacyIndex(NamedNode[Literal["legacy_index"]]): ...

class NewIndex(NamedNode[Literal["new_index"]]):
    ...

    @property
    @override
    def named_children(self) -> list[Expression]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[Expression]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class NumericLit(NamedNode[Literal["numeric_lit"]]): ...

class Object(NamedNode[Literal["object"]]):
    ...
    @override
    def children_by_field_name(
        self, name: Literal["elements"], /
    ) -> list[ObjectElem]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[ObjectEnd | ObjectStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[ObjectEnd | ObjectStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class ObjectElem(NamedNode[Literal["object_elem"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["key"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["val"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class ObjectEnd(NamedNode[Literal["object_end"]]): ...
class ObjectStart(NamedNode[Literal["object_start"]]): ...

class ParenthesizedExpression(NamedNode[Literal["parenthesized_expression"]]):
    ...

    @property
    @override
    def named_children(self) -> list[Expression]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[Expression]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class QuotedTemplate(NamedNode[Literal["quoted_template"]]):
    ...
    @override
    def child_by_field_name(self, name: Literal["body"], /) -> Template | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[QuotedTemplateEnd | QuotedTemplateStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[QuotedTemplateEnd | QuotedTemplateStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class StringLit(NamedNode[Literal["string_lit"]]):
    ...
    @override
    def child_by_field_name(
        self, name: Literal["body"], /
    ) -> TemplateLiteral | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[QuotedTemplateEnd | QuotedTemplateStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[QuotedTemplateEnd | QuotedTemplateStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class Template(NamedNode[Literal["template"]]):
    ...

    @property
    @override
    def named_children(
        self,
    ) -> list[TemplateDirective | TemplateInterpolation | TemplateLiteral]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(
        self,
    ) -> list[TemplateDirective | TemplateInterpolation | TemplateLiteral]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TemplateDirective(NamedNode[Literal["template_directive"]]):
    ...

    @property
    @override
    def named_children(self) -> list[TemplateFor | TemplateIf]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[TemplateFor | TemplateIf]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TemplateElseIntro(NamedNode[Literal["template_else_intro"]]):
    ...
    @override
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_end"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_start"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[TemplateDirectiveEnd | TemplateDirectiveStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[TemplateDirectiveEnd | TemplateDirectiveStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TemplateFor(NamedNode[Literal["template_for"]]):
    ...

    @property
    @override
    def named_children(self) -> list[Template | TemplateForEnd | TemplateForStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[Template | TemplateForEnd | TemplateForStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TemplateForEnd(NamedNode[Literal["template_for_end"]]):
    ...
    @override
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_end"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_start"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[TemplateDirectiveEnd | TemplateDirectiveStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[TemplateDirectiveEnd | TemplateDirectiveStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TemplateForStart(NamedNode[Literal["template_for_start"]]):
    ...
    @override
    def children_by_field_name(self, name: Literal["left"], /) -> list[Identifier]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @override
    @overload
    def child_by_field_name(self, name: Literal["right"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_end"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_start"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[TemplateDirectiveEnd | TemplateDirectiveStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[TemplateDirectiveEnd | TemplateDirectiveStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TemplateIf(NamedNode[Literal["template_if"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["else_body"], /) -> Template | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["else_intro"], /
    ) -> TemplateElseIntro | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["if_body"], /) -> Template | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(self, name: Literal["if_intro"], /) -> TemplateIfIntro: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[TemplateIfEnd]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[TemplateIfEnd]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TemplateIfEnd(NamedNode[Literal["template_if_end"]]):
    ...
    @override
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_end"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_start"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[TemplateDirectiveEnd | TemplateDirectiveStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[TemplateDirectiveEnd | TemplateDirectiveStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TemplateIfIntro(NamedNode[Literal["template_if_intro"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["condition"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_end"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_start"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[TemplateDirectiveEnd | TemplateDirectiveStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[TemplateDirectiveEnd | TemplateDirectiveStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TemplateInterpolation(NamedNode[Literal["template_interpolation"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["body"], /) -> Expression: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_end"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["strip_marker_start"], /
    ) -> StripMarker | None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(
        self,
    ) -> list[TemplateInterpolationEnd | TemplateInterpolationStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(
        self,
    ) -> list[TemplateInterpolationEnd | TemplateInterpolationStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TemplateLiteral(NamedNode[Literal["template_literal"]]): ...

class Tuple(NamedNode[Literal["tuple"]]):
    ...
    @override
    def children_by_field_name(
        self, name: Literal["elements"], /
    ) -> list[Expression]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def named_children(self) -> list[TupleEnd | TupleStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def children(self) -> list[TupleEnd | TupleStart]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class TupleEnd(NamedNode[Literal["tuple_end"]]): ...
class TupleStart(NamedNode[Literal["tuple_start"]]): ...

class UnaryOperation(NamedNode[Literal["unary_operation"]]):
    ...
    @override
    @overload
    def child_by_field_name(self, name: Literal["operand"], /) -> ExprTerm: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def child_by_field_name(
        self, name: Literal["operator"], /
    ) -> UnnamedNode[Literal["!"]] | UnnamedNode[Literal["-"]]: ...  # pyright: ignore[reportIncompatibleMethodOverride]

class Comment(NamedNode[Literal["comment"]]): ...
class Ellipsis(NamedNode[Literal["ellipsis"]]): ...
class ForInitializerSingle(NamedNode[Literal["for_initializer_single"]]): ...
class HeredocIdentifier(NamedNode[Literal["heredoc_identifier"]]): ...
class Identifier(NamedNode[Literal["identifier"]]): ...
class NullLit(NamedNode[Literal["null_lit"]]): ...
class QuotedTemplateEnd(NamedNode[Literal["quoted_template_end"]]): ...
class QuotedTemplateStart(NamedNode[Literal["quoted_template_start"]]): ...
class StripMarker(NamedNode[Literal["strip_marker"]]): ...
class TemplateDirectiveEnd(NamedNode[Literal["template_directive_end"]]): ...
class TemplateDirectiveStart(NamedNode[Literal["template_directive_start"]]): ...
class TemplateInterpolationEnd(NamedNode[Literal["template_interpolation_end"]]): ...
class TemplateInterpolationStart(
    NamedNode[Literal["template_interpolation_start"]]
): ...

CollectionValue = Object | Tuple
ExprTerm = (
    UnaryOperation
    | ParenthesizedExpression
    | FunctionCall
    | CollectionValue
    | Splat
    | BinaryOperation
    | HeredocTemplate
    | ForExpr
    | Identifier
    | Index
    | QuotedTemplate
    | LiteralValue
    | GetAttr
)
Expression = ExprTerm | Conditional
ForExpr = ForObjectExpr | ForTupleExpr
LiteralValue = BoolLit | StringLit | NumericLit | NullLit
Splat = FullSplat | AttrSplat
HclNode = (
    CollectionValue
    | ExprTerm
    | Expression
    | ForExpr
    | LiteralValue
    | Splat
    | AttrSplat
    | Attribute
    | BinaryOperation
    | Block
    | BlockEnd
    | BlockStart
    | Body
    | BoolLit
    | Conditional
    | ConfigFile
    | ForInitializerPair
    | ForIntro
    | ForObjectExpr
    | ForTupleExpr
    | FullSplat
    | FunctionCall
    | GetAttr
    | HeredocStart
    | HeredocTemplate
    | Index
    | LegacyIndex
    | NewIndex
    | NumericLit
    | Object
    | ObjectElem
    | ObjectEnd
    | ObjectStart
    | ParenthesizedExpression
    | QuotedTemplate
    | StringLit
    | Template
    | TemplateDirective
    | TemplateElseIntro
    | TemplateFor
    | TemplateForEnd
    | TemplateForStart
    | TemplateIf
    | TemplateIfEnd
    | TemplateIfIntro
    | TemplateInterpolation
    | TemplateLiteral
    | Tuple
    | TupleEnd
    | TupleStart
    | UnaryOperation
    | UnnamedNode[Literal["!"]]
    | UnnamedNode[Literal["!="]]
    | UnnamedNode[Literal["%"]]
    | UnnamedNode[Literal["&&"]]
    | UnnamedNode[Literal["("]]
    | UnnamedNode[Literal[")"]]
    | UnnamedNode[Literal["*"]]
    | UnnamedNode[Literal["+"]]
    | UnnamedNode[Literal[","]]
    | UnnamedNode[Literal["-"]]
    | UnnamedNode[Literal["."]]
    | UnnamedNode[Literal[".*"]]
    | UnnamedNode[Literal["/"]]
    | UnnamedNode[Literal[":"]]
    | UnnamedNode[Literal["<"]]
    | UnnamedNode[Literal["<<"]]
    | UnnamedNode[Literal["<<-"]]
    | UnnamedNode[Literal["<="]]
    | UnnamedNode[Literal["="]]
    | UnnamedNode[Literal["=="]]
    | UnnamedNode[Literal["=>"]]
    | UnnamedNode[Literal[">"]]
    | UnnamedNode[Literal[">="]]
    | UnnamedNode[Literal["?"]]
    | UnnamedNode[Literal["["]]
    | UnnamedNode[Literal["[*]"]]
    | UnnamedNode[Literal["]"]]
    | Comment
    | Ellipsis
    | UnnamedNode[Literal["else"]]
    | UnnamedNode[Literal["endfor"]]
    | UnnamedNode[Literal["endif"]]
    | UnnamedNode[Literal["false"]]
    | UnnamedNode[Literal["for"]]
    | ForInitializerSingle
    | HeredocIdentifier
    | Identifier
    | UnnamedNode[Literal["if"]]
    | UnnamedNode[Literal["in"]]
    | NullLit
    | QuotedTemplateEnd
    | QuotedTemplateStart
    | StripMarker
    | TemplateDirectiveEnd
    | TemplateDirectiveStart
    | TemplateInterpolationEnd
    | TemplateInterpolationStart
    | UnnamedNode[Literal["true"]]
    | UnnamedNode[Literal["{"]]
    | UnnamedNode[Literal["||"]]
    | UnnamedNode[Literal["}"]]
)
